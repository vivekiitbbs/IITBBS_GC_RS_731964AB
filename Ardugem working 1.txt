/*
OneLoneCoder.com - Code-It-Yourself! Simple Tile Based Platform Game
"Its-a meee-a Jario!" - @Javidx9
License
~~~~~~~
Copyright (C) 2018  Javidx9
This program comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it
under certain conditions; See license for details.
Original works located at:
https://www.github.com/onelonecoder
https://www.onelonecoder.com
https://www.youtube.com/javidx9
GNU GPLv3
https://github.com/OneLoneCoder/videos/blob/master/LICENSE
From Javidx9 :)
~~~~~~~~~~~~~~~
Hello! Ultimately I don't care what you use this for. It's intended to be
educational, and perhaps to the oddly minded - a little bit of fun.
Please hack this, change it and use it in any way you see fit. You acknowledge
that I am not responsible for anything bad that happens as a result of
your actions. However this code is protected by GNU GPLv3, see the license in the
github repo. This means you must attribute me if you use it. You can view this
license here: https://github.com/OneLoneCoder/videos/blob/master/LICENSE
Cheers!
Background
~~~~~~~~~~
Tile maps are fundamental to most 2D games. This program explores emulating a classic 2D platformer
using floating point truncation to implement robust collision between a moving tile and a tilemap
representing the level.
Controls
~~~~~~~~
Left and Right arrow keys move Jario, Space bar jumps.
(Up and Down also move jario)
Author
~~~~~~
Twitter: @javidx9
Blog: www.onelonecoder.com
YouTube: www.youtube.com/javidx9
Discord: https://discord.gg/WhwHUMV
Video:
~~~~~~
https://youtu.be/oJvJZNyW_rw
Last Updated: 04/02/2018
*/

#include <iostream>
#include <string>
#include <Windows.h>
#include<conio.h>

using namespace std;

#include "olcConsoleGameEngine.h"

class OneLoneCoder_Platformer : public olcConsoleGameEngine
{
public:
	OneLoneCoder_Platformer()
	{
		m_sAppName = L"Tile Based Platform Game";
	}

private:
	// Level storage

	int nLevelWidth;
	int nLevelHeight;
	wstring sLevel, slevel1, slevel2, slevel3, slevel4;
	float fPlayerPosX = 12.0f;
	float fPlayerPosY = 27.0f;
	float fPlayerVelX = 0.0f;
	float fPlayerVelY = 0.0f;
	bool bPlayerOnGround = false;
	int nDirModX = 0;
	int nDirModY = 0;

protected:
	virtual bool OnUserCreate()
	{
		nLevelWidth = 32;
		nLevelHeight = 30;


		sLevel += L"B..............................B";
		sLevel += L"B..............GGGGGGG.........B";
		sLevel += L"B..............................B";
		sLevel += L"B..............................B";
		sLevel += L"B..BBBBBBBBBBBB...........BBBBBB";
		sLevel += L"B..............................B";
		sLevel += L"B..............#######.........B";
		sLevel += L"B..............................B";
		sLevel += L"BBBBBBB........................B";
		sLevel += L"B.....................#######..B";
		sLevel += L"B..............................B";
		sLevel += L"B..............BBBBBBB.........B";
		sLevel += L"B..............................B";
		sLevel += L"B.......BBBB...........#####...B";
		sLevel += L"B..............................B";
		sLevel += L"B...............GGG............B";
		sLevel += L"B..............................B";
		sLevel += L"B......................########B";
		sLevel += L"B....BBBBBBBBBBBB..............B";
		sLevel += L"B..............................B";
		sLevel += L"B..............................B";
		sLevel += L"B..........GGGGGGGGGG..........B";
		sLevel += L"B.......................GGG....B";
		sLevel += L"B..........................G...B";
		sLevel += L"BBBBBBB........................B";
		sLevel += L"B......GGG...............######B";
		sLevel += L"B...............GGGGGGG........B";
		sLevel += L"B..............................B";
		sLevel += L"BGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGB";
		sLevel += L"B..............................B";


		return true;
	}

	virtual bool OnUserUpdate(float fElapsedTime)
	{
		// Utility Lambdas
		auto GetTile = [&](int x, int y)
		{
			if (x >= 0 && x < nLevelWidth && y >= 0 && y < nLevelHeight)
				return sLevel[y * nLevelWidth + x];
			else
				return L' ';
		};

		auto SetTile = [&](int x, int y, wchar_t c)
		{
			if (x >= 0 && x < nLevelWidth && y >= 0 && y < nLevelHeight)
				sLevel[y * nLevelWidth + x] = c;
		};

		if (IsFocused())
		{
			if (GetKey(VK_UP).bPressed && bPlayerOnGround==true)
			{
				fPlayerVelY = -40.0f;
			}

			if (GetKey(VK_DOWN).bHeld)
			{
				fPlayerVelY = 6.0f;
			}

			if (GetKey(VK_LEFT).bHeld)
			{
				fPlayerVelX += ( -2000.0f) * fElapsedTime;
				nDirModY = 1;
			}

			if (GetKey(VK_RIGHT).bHeld)
			{
				fPlayerVelX += ( 2000.0f) * fElapsedTime;
				nDirModY = 0;
			}

			if (GetKey(VK_SPACE).bPressed)
			{
				if (fPlayerVelY == 0)
				{
					fPlayerVelY = -12.0f;
					nDirModX = 1;
				}
			}
		}

		// Gravity
		fPlayerVelY += 10.0f * pow(fElapsedTime,0.5);

		// Drag
		/*if (bPlayerOnGround)
		{
			fPlayerVelX += -3.0f * fPlayerVelX * fElapsedTime;
			if (fabs(fPlayerVelX) < 0.01f)
				fPlayerVelX = 0.0f;
		}*/

		// Clamp velocities
		if (fPlayerVelX > 2000.0f)
			fPlayerVelX = 2000.0f;

		if (fPlayerVelX < -2000.0f)
			fPlayerVelX = -2000.0f;

		if (fPlayerVelY > 100.0f)
			fPlayerVelY = 100.0f;

		if (fPlayerVelY < -100.0f)
			fPlayerVelY = -100.0f;

		// Calculate potential new position
		float fNewPlayerPosX = fPlayerPosX + (fPlayerVelX * fElapsedTime);
		float fNewPlayerPosY = fPlayerPosY + (fPlayerVelY * fElapsedTime);

		
		// Check for Collision
		if (fPlayerVelX < 0) // Moving Left
		{
			if (GetTile(fNewPlayerPosX + 0.0f, fPlayerPosY + 0.0f) != L'.' || GetTile(fNewPlayerPosX + 0.0f, fPlayerPosY + 0.9f) != L'.')
			{
				fNewPlayerPosX = (int)fNewPlayerPosX +1;
				fPlayerVelX = 0;
			}
		}
		else // Moving Right
		{
			if (GetTile(fNewPlayerPosX + 1.0f, fPlayerPosY + 0.0f) != L'.' || GetTile(fNewPlayerPosX + 1.0f, fPlayerPosY + 0.9f) != L'.')
			{
				fNewPlayerPosX = (int)fNewPlayerPosX;
				fPlayerVelX = 0;

			}
		}

		bPlayerOnGround = false;
		if (fPlayerVelY < 0) // Moving Up
		{
			if (GetTile(fNewPlayerPosX + 0.0f, fNewPlayerPosY) != L'.' || GetTile(fNewPlayerPosX + 0.9f, fNewPlayerPosY) != L'.')
			{
				fNewPlayerPosY = (int)fNewPlayerPosY +1;
				fPlayerVelY = 0;
			}
		}
		else // Moving Down
		{
			if (GetTile(fNewPlayerPosX + 0.0f, fNewPlayerPosY + 1.0f) != L'.' || GetTile(fNewPlayerPosX + 0.9f, fNewPlayerPosY + 1.0f) != L'.')
			{
				fNewPlayerPosY = (int)fNewPlayerPosY;
				fPlayerVelY = 0;
				bPlayerOnGround = true; // Player has a solid surface underfoot
				nDirModX = 0;
			}
		}

		// Apply new position
		fPlayerPosX = fNewPlayerPosX;
		fPlayerPosY = fNewPlayerPosY;
		// Draw Level
		
		
		int nTileWidth = 1;
		int nTileHeight = 1;
		int nVisibleTilesX = 32;
		int nVisibleTilesY = 32;
		// Draw visible tile map
		for (int x = 0; x < nVisibleTilesX + 1; x++)
		{
			for (int y = fPlayerPosY-27; y < nVisibleTilesY + 25 - fPlayerPosY; y++)
			{
				wchar_t sTileID = GetTile(x, y);
				switch (sTileID)
				{
				case L'.': // Sky
					Fill(x * nTileWidth, (y ) * nTileHeight, (x + 1) * nTileWidth, ((y ) + 1) * nTileHeight, PIXEL_SOLID, FG_CYAN);
					break;
				case L'#': // Solid Block
					Fill(x * nTileWidth, (y ) * nTileHeight, (x + 1) * nTileWidth, ((y ) + 1) * nTileHeight, PIXEL_SOLID, FG_WHITE);
					//DrawPartialSprite(x * nTileWidth  , y * nTileHeight  , spriteTiles, 2 * nTileWidth, 0 * nTileHeight, nTileWidth, nTileHeight);
					break;
				case L'G': // Ground Block
					Fill(x * nTileWidth, (y) * nTileHeight, (x + 1) * nTileWidth, ((y ) + 1) * nTileHeight, PIXEL_SOLID, FG_WHITE);
					break;
				case L'B': // Brick Block
					Fill(x * nTileWidth, (y ) * nTileHeight, (x + 1) * nTileWidth, ((y ) + 1) * nTileHeight, PIXEL_SOLID, FG_RED);
					break;
				//case L'o': // Coin
					//Fill(x * nTileWidth, y * nTileHeight, (x + 1) * nTileWidth, (y + 1) * nTileHeight, PIXEL_SOLID, FG_CYAN);
					//DrawPartialSprite(x * nTileWidth  , y * nTileHeight  , spriteTiles, 3 * nTileWidth, 0 * nTileHeight, nTileWidth, nTileHeight);
					//break;
				default:
					Fill(x * nTileWidth, (y ) * nTileHeight, (x + 1) * nTileWidth, ((y) + 1) * nTileHeight, PIXEL_SOLID, FG_BLACK);
					break;
				}
			}
		}
		Fill((fPlayerPosX), (fPlayerPosY ), (fPlayerPosX +1.0f), (fPlayerPosY + 1.0f), PIXEL_SOLID, FG_GREEN);
		//cout << fPlayerPosX << fPlayerPosY;
		fPlayerVelX = 0.25;
		return true;
		
	}
};

int main()
{
	OneLoneCoder_Platformer game;
	if (game.ConstructConsole(32,32,1,1))
		game.Start();
	return 0;
}

